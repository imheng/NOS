#第十五节课
##一、	例题：
####对于64位虚拟地址，4KB的页，1GB的RAM，有多少页表项？
![解答过程](b.com/wangjuanli/Markdown/blob/master/例题.PNG)
##二、	页面置换算法
###1.	最优页面置换算法
工作原理：在缺页中断发生时，有些页面在内存中，其中有一个页面（包括紧接着的下一条指令的页面）将很快被访问，其他页面则可能要到10、100或1000条指令后才会被访问。每个页面都可以用在该页面首次被访问前所要执行的指令数作为标记。最有页面置换算法规定应该置换标记最大的页面。
###2.	最近未使用页面置换算法
工作原理：当页面被访问（读或写）时设置R位，，当页面（即修改页面）被写入时设置M位。这些位包含在页表项中。每次访问内存时更新这些位，因此由硬件设置它们是必要的。一旦设置某位为1，它就一直保持1直到操作系统将它复位。
当发生缺页中断时，操作系统检查所有的页面并根据它们当前的R位和M位，把它们分为4类：
第0类：没有被访问，没有被修改。
第1类：没有被访问，已被修改。
第2类：已被访问，没有被修改。
第3类：已被访问，已被修改。
###3.	先进先出页面置换算法
工作原理;由操作系统维护一个当前在内存中的页面的链表，最新进入的页面放在表尾，最久进入的页面放在表头。当发生缺页中断时，淘汰表头的页面并把新调入的页面加到表尾。
###4.	第二次机会页面置换算法
工作原理：FIFO算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一简单的修改：检查最老页面的R位。如果R位是0，那么这个页面既老又没有被使用，可以立刻置换掉；如果R位是1，就将R位清0，并把该页面放到链表的尾端，修改它的装入时间就像刚装入的一样，然后继续搜索。
###5.	时钟页面置换算法
工作原理：当发生缺页中断时，算法首先检查表针指向的页面，如果它的R位是0就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；如果R位是1就清除R位并把表针前移一个位置，重复这个过程直到找到了一个R位为0的位置为止。
###6.	最近最少使用页面置换算法
工作原理：在缺页中断发生时，置换未使用时间最长的页面。
##三、	页面置换算法总结
     算法	               |注释                    
     最优算法             |不可实现，但可用作基准   
     NRU最近未使用算法     |LRU很粗糙的近似         
     FIFO先进先出算法	     |可能抛弃重要页面         
     第二次机会算法	    |比FIFO有大的改善        
     时钟算法	          |现实的                 
     LRU最近最少使用算法   |很优秀，但很难实现       
 
　　FIFO算法通过维护一个页面的链表来记录它们装入内存的顺序。淘汰的是最老的页面，但是该页面可能仍在使用，因此FIFO不是一个最好的选择。

　　第二次机会算法是对FIFO算法的改进，它在移除页面前先检查该页面是否正在被使用。如果该页面正在被使用，就保留该页面。这个改进大大提高了性能。

　　时钟算法是第二次机会算法的另一种体现，它具有相同的性能特征，而且只需要更少的执行时间。
##四、	共享库
　　.so是 Linux共享库

    优点：（1）使可执行文件更小，节省内存空间。
         （2）如果共享库中的一个函数因为修正一个bug被更新了，那么并不需要重新编译调用了这个函数的程序。
